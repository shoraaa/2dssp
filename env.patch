*** a/env.py
--- b/env.py
@@
-    def generate_candidates(self) -> List[Tuple[int, int, int, bool, int]]:
+    def generate_candidates(self) -> List[Tuple[int, int, int, bool, int, int]]:
         """
         Generate all feasible candidate actions for the current state.
@@
-        Returns:
-            List of tuples (tile_id, x, y, is_adjacent, best_overlap_size)
+        Returns:
+            List of tuples (tile_id, x, y, is_adjacent, best_overlap_size, H_sum)
             where (x, y) is the top-left position for placing the tile
         """
-        cands: List[Tuple[int, int, int, bool, int]] = []
+        cands: List[Tuple[int, int, int, bool, int, int]] = []
         n = self.n
         occ = self.occ
@@
-            feasible_overlap_found = False
+            feasible_overlap_found = False
 
             # Check overlap candidates for feasibility
             for (x, y) in overlap_positions:
                 if not feasible_on_occupancy(self.tiles[v], x, y, occ):
                     continue
                     
-                # Calculate best overlap size among all parent tiles
-                best_ov = 0
+                # Calculate best overlap and H_sum among all parent tiles
+                best_ov = 0
+                H_sum = 0
                 for u in self.placed_ids:
                     ux, uy = self.placements[u]
                     dx, dy = x - ux, y - uy
                     for (dx0, dy0, ov) in self.pre_all.get((u, v), []):
                         if dx0 == dx and dy0 == dy:
-                            if ov > best_ov: 
-                                best_ov = ov
+                            if ov > best_ov:
+                                best_ov = ov
+                            H_sum += ov
                             break
                 
-                cands.append((v, x, y, False, best_ov))
+                cands.append((v, x, y, False, best_ov, H_sum))
                 feasible_overlap_found = True
@@
                 for (x, y) in adj_positions:
                     if not feasible_on_occupancy(self.tiles[v], x, y, occ):
                         continue
                     # Adjacent placements have no overlap by definition
-                    cands.append((v, x, y, True, 0))
+                    cands.append((v, x, y, True, 0, 0))
 
         return cands
@@
-    def step(self, cand: Tuple[int, int, int, bool, int]):
+    def step(self, cand: Tuple[int, int, int, bool, int, int]):
         """
         Apply a candidate action to the environment.
@@
-        v, x, y, is_adj, best_ov = cand
+        v, x, y, is_adj, best_ov, H_sum = cand  # H_sum kept for compatibility though unused here
         assert v in self.remaining, f"Tile {v} is not in remaining tiles"
         
         # Update occupancy grid and bounding box
         write_to_occupancy(self.tiles[v], x, y, self.occ)
         update_bbox_for_tile(x, y, self.n, self.bbox)
@@
         if len(self.placed_ids) == self.T:
             self.done = True
             
         return self.state()
+
+    def step_and_metrics(self, cand: Tuple[int, int, int, bool, int, int]) -> Tuple[dict, int, int]:
+        """
+        Apply action and return (state, delta_m, H_sum).
+        delta_m is computed *without* calling layout_bbox by using the current bbox.
+        """
+        v, x, y, is_adj, best_ov, H_sum = cand
+        # compute bbox increase before writing
+        delta_m = bbox_increase_if_place(x, y, self.n, self.bbox)
+        st = self.step(cand)
+        return st, int(delta_m), int(H_sum)
@@
 def build_step_batch_from_env(
@@
-    raw_cands = env.generate_candidates()
+    raw_cands = env.generate_candidates()
     if len(raw_cands) == 0:
@@
-    # Pre-compute H_sum (total overlap) for each candidate
-    Hs: List[float] = []
-    for (v, x, y, is_adj, best_ov) in raw_cands:
-        H_sum = 0
-        for u in env.placed_ids:
-            ux, uy = env.placements[u]
-            dx, dy = x - ux, y - uy
-            for (dx0, dy0, ov) in env.pre_all.get((u, v), []):
-                if dx0 == dx and dy0 == dy:
-                    H_sum += ov
-                    break
-        Hs.append(float(H_sum))
-
-    # Build feature vectors for each candidate
-    for idx, (v, x, y, is_adj, best_ov) in enumerate(raw_cands):
+    # Build feature vectors for each candidate (now we already have H_sum from env)
+    for (v, x, y, is_adj, best_ov, H_sum) in raw_cands:
         # Canvas size increase if this tile is placed
         inc = bbox_increase_if_place(x, y, n, env.bbox)
@@
-        feats.append([
-            Hs[idx],        # Total overlap size
+        feats.append([
+            float(H_sum),   # Total overlap size
             float(inc),     # Canvas size increase  
             float(dxn),     # Normalized x position
             float(dyn),     # Normalized y position
             float(is_adj),  # Is adjacency placement (vs overlap)
             float(best_ov), # Best overlap with any parent
             left_touch,     # Touches left edge
             right_touch,    # Touches right edge  
             up_touch,       # Touches top edge
             down_touch      # Touches bottom edge
         ])
         
         # Map tile ID to its index in the remaining tiles list
-        tile_idx.append(remaining.index(v))
+        tile_idx.append(remaining.index(v))
         mask.append(True)
@@
     return sb if device is None else sb.to(device)
